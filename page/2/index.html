<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="尘世幽梦的BLOG">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="尘世幽梦的BLOG">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>尘世幽梦的BLOG</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">尘世幽梦的BLOG</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/14/React-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%8Eclass%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尘世幽梦的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/14/React-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%8Eclass%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">React-函数组件与class组件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-14 16:02:04 / Modified: 17:08:16" itemprop="dateCreated datePublished" datetime="2022-03-14T16:02:04+08:00">2022-03-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="React-函数组件与class组件"><a href="#React-函数组件与class组件" class="headerlink" title="React-函数组件与class组件"></a>React-函数组件与class组件</h1><p>组件名称必须以大写字母开头。</p>
<h2 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h2><p>  所有 React 组件都必须像纯函数(不更改入参)一样保护它们的 props 不被更改</p>
<p>  函数组件本质上一个Javascript函数，接收唯一一个带数据的props(只读)属性对象，返回一个React元素</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Hi(props) &#123;</span><br><span class="line">  return &lt;h1&gt;hi, my world, &#123;&#123; props.date&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a>class组件</h2><p>  State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件</p>
<p>  不要直接修改 State, 应该使用 this.setState() 来时刻更新组件 state</p>
<p>  存在多个state更新时，state的更新可能是异步的，建议让setState接收一个函数而不是对象，这个函数用上一个state作为第一参数，将props作为第二个参数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState((state, props) &#x3D;&gt; (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Hi extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123; &#x2F;&#x2F; 构造函数是唯一可以给 this.state 赋值的地方</span><br><span class="line">    &#x2F;&#x2F; Class 组件应该始终使用 props 参数来调用父类的构造函数。</span><br><span class="line">    super(props); </span><br><span class="line">    this.state &#x3D; &#123;date: new Date()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      date: new Date()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><h4 id="受控组件输入空值"><a href="#受控组件输入空值" class="headerlink" title="受控组件输入空值"></a>受控组件输入空值</h4><p>  在受控组件上指定 value 属性会阻止用户更改输入（没有使用 onChange 去更改 value 绑定的值时）。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输入最初被锁定，但在短时间延迟后变为可编辑</span><br><span class="line">ReactDOM.render(&lt;input value&#x3D;&quot;hi&quot; &#x2F;&gt;, mountNode);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  ReactDOM.render(&lt;input value&#x3D;&#123;null&#125; &#x2F;&gt;, mountNode);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/git%E7%9A%84%E4%BD%BF%E7%94%A8-%E6%8E%98%E9%87%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尘世幽梦的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/21/git%E7%9A%84%E4%BD%BF%E7%94%A8-%E6%8E%98%E9%87%91/" class="post-title-link" itemprop="url">git的使用-掘金</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-21 15:50:05 / Modified: 15:53:40" itemprop="dateCreated datePublished" datetime="2022-02-21T15:50:05+08:00">2022-02-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>来源：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6967634683811069982">掘金-一份工作4年前端的Git备忘指南</a></p>
<p>Git常用命令</p>
<p>git克隆远程分支仓库：</p>
<p>git clone -b 分支名称 远程地址<br>git克隆远程仓库项目时如果不指定分支，只会克隆默认分支的内容。</p>
<p>查看git用户名和邮箱</p>
<p>git config user.name<br>git config user.email<br>复制代码</p>
<p>分支相关</p>
<p>git branch（查看当前分支)<br>git branch -a（查看所有分支）<br>git checkout 分支名（切换到对应分支） 会自动将代码更新为分支代码<br>git branch 分支名（创建一个分支）<br>git branch -d 分支名（删除一个分支）<br>git branch -D 分支名（强制删除一个未合并的分支）<br>git checkout -b 分支名 [基于的分支名或commit值]（切换分支并直接切换过去）<br>复制代码</p>
<p>查看git历史</p>
<p>history</p>
<p>按照关键词搜索git历史</p>
<p>history | grep push</p>
<p>查看commit历史</p>
<p>git log<br>git log –summary<br>复制代码</p>
<p>设置git账号</p>
<p>git config –global user.name “foo”<br>git config –global user.email <a href="mailto:&#x66;&#111;&#x6f;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;">&#x66;&#111;&#x6f;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a>“<br>git config user.name “foo”<br>git config user.email “<a href="mailto:&#102;&#111;&#x6f;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;">&#102;&#111;&#x6f;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;</a>“<br>复制代码</p>
<p>查看git账号</p>
<p>git config –global –list<br>git config –local –list<br>复制代码</p>
<p>仅仅查看某一项的配置</p>
<p>git config –local user.name</p>
<p>回滚本次修改</p>
<p>git reset HEAD foo.js<br>git checkout – foo.js<br>复制代码</p>
<p>查看本次修改的代码</p>
<p>git diff<br>git diff HEAD<br>git diff –staged<br>复制代码</p>
<p>提交后发现丢了几个文件没有提交</p>
<p>发现丢了修改记录，重新添加<br>git add “*.html”<br>重新提交，最终只有一个提交<br>git commit –amend<br>复制代码</p>
<p>缓存某种后缀的文件</p>
<p>git add “*.js”</p>
<p>清除缓存区中的文件</p>
<p>git reset octofamily/octodog.txt</p>
<p>彻底删除某种后缀的文件</p>
<p>git rm “*.txt”</p>
<p>合并分支到master</p>
<p>git merge 分支名</p>
<p>add .之前取消提交某些文件</p>
<p>git checkout – <filename></p>
<p>藏代码到脏目录（适用于其他成员修改了相同分支代码，但又不想提交）</p>
<p>git stash</p>
<p>释放脏目录代码</p>
<p>git stash pop</p>
<p>释放指定脏目录代码</p>
<p>git stash pop stash@{0}</p>
<p>删除远程分支(此分支必须是非默认分支)</p>
<p>git push origin –delete branchname</p>
<p>已经commit，强制回退到旧版本</p>
<p>git log//找到commit hash值<br>git reset –hard hash值<br>复制代码</p>
<p>查看stash目录</p>
<p>git stash list</p>
<p>删除某一个stash</p>
<p>git stash drop stash@{0}</p>
<p>设置远程仓库地址</p>
<p>git remote set-url origin <a href="mailto:&#103;&#x69;&#116;&#x40;&#x66;&#x6f;&#111;&#x2e;&#98;&#x61;&#x72;&#x2e;&#x63;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#x66;&#x6f;&#111;&#x2e;&#98;&#x61;&#x72;&#x2e;&#x63;&#111;&#109;</a>:baz/helloworld.git</p>
<p>本地创建了新分支，但是orgin没有，push代码前</p>
<p>git push –set-upstream origin preproduction</p>
<p>指定tag到远程</p>
<p>git push origin <tag_name></p>
<p>将全部tag打到远程</p>
<p>git push –tags</p>
<p>查看当前tags</p>
<p>git tag –list</p>
<p>仅仅删除index不删除working tree上的.idea文件</p>
<p>git rm –cached -r .idea // –cached仅仅删除index，-r（recursive）递归删除.idea目录下的所有文件</p>
<p>git主动track文件，控制文件，做好提交准备</p>
<p>git add &lt;file(s)&gt;/.</p>
<p>git unstage文件，释放文件，选择性控制</p>
<p>git reset HEAD &lt;file(s)&gt;/.</p>
<p>暂存区文件如何覆盖工作目录文件</p>
<p>git reset HEAD &lt;file(s)&gt;/. &amp;&amp; git checkout – &lt;file(s)&gt;/.</p>
<p>提交已经被git管理的，modified为红色的所有文件</p>
<p>git add -u</p>
<p>重置工作区和暂存区的所有文件为原始状态</p>
<p>git reset –hard</p>
<p>比较当前分支与某次提交的区别</p>
<p>git diff HEAD [commit hash fragment]</p>
<p>删除一个分支</p>
<p>git branch -D [branch name]</p>
<p>同步到remote后，合并多个commit 为1个</p>
<p>git rebase -i HEAD~2/hash<br>pick &amp;&amp; squash<br>:wq!<br>复制代码</p>
<p>查看项目的origin代表的地址</p>
<p>git remote -v</p>
<p>pick中途误退出</p>
<p>git rebase –abort</p>
<p>未同步到remote，重新提交</p>
<p>reset soft</p>
<p>gitflow release 发布新版本</p>
<p>git flow release start v0.5.0<br>npm version minor<br>git flow release finish -n<br>git push<br>git checkout master<br>git push<br>复制代码</p>
<p>gitflow hotfix 修复一个master上的bug</p>
<p>git flow hotfix start foo<br>npm version patch // 注意：一定要在修复bug代码之前新增版本号<br>git add .<br>git commit -m “version change message”<br>git flow hotfix finish -n<br>git push<br>git checkout master<br>git push<br>复制代码</p>
<p>对比2个分支的日志</p>
<p>git log develop..master<br>复制代码</p>
<p>合并master代码到feature</p>
<p>git checkout feature<br>git merge master<br>复制代码<br>git merge master feature<br>复制代码</p>
<p>git rebase冲突时怎么办</p>
<p>resolve conficts<br>git add .<br>git rebase –continue<br>复制代码</p>
<p>squash多个commits成一个怎么敲？</p>
<p>假设merge feature到master。<br>git checkout master<br>git merge –squash feature<br>git commit -m “这是一次squash commit”<br>git push<br>复制代码</p>
<p>查看当前分支的父分支</p>
<p>git reflog show <childBranch><br>32c3956 (HEAD -&gt; currentBranch, origin/fatherBranch, fatherBranch, list) childBranch@{0}: branch: Created from fatherBranch<br>复制代码<br>childBranch 是你新建的分支。<br>fatherBranch 是它的父分支，也就是来源分支。</p>
<p>撤销远程分支错误提交</p>
<p>…reset<br>git push –force<br>复制代码<br>其实使用本地分支的提交替代远程分支。</p>
<p>误删除领先远程的本地分支如何恢复？</p>
<p>git reflog // 找出最新的commit sha1值，HEAD@{1}比HEAD@{2}新<br>git branch branchName <sha1><br>复制代码<br>通过git reflog找到一个commit，然后再cherry-pick也可以。</p>
<p>删除由npm version patch/minor/major误添加的tag</p>
<p>git tag | grep v1.1.38<br>git tag -d v1.1.38<br>git push origin :refs/tags/v1.1.38<br>复制代码</p>
<p>git fetch与git pull的区别</p>
<p>git fetch 更新origin/*下的所有分支，在发布git flow feature前很有用，用于更新remote分支。<br>git pull 主要用来更新多人合作的当前分支，多用于更新local分支。<br>// <a target="_blank" rel="noopener" href="https://www.git-tower.com/learn/git/faq/difference-between-git-fetch-git-pull">https://www.git-tower.com/learn/git/faq/difference-between-git-fetch-git-pull</a><br>复制代码</p>
<p>远程分支删除，本地git fetch不能更新到最新分支</p>
<p>git fetch –prune</p>
<p>–prune什么意思？<br>Before fetching, remove any remote-tracking references that no longer exist on the remote.<br>复制代码</p>
<p>及时查看本地所有分支的状态</p>
<p>git remote show origin<br>复制代码</p>
<p>假如远程已不存在这个分支，git fetch –prune也更新不到状态，该怎么办？</p>
<p>git push origin –delete feature/fix-chat-unread-msg-async<br>复制代码</p>
<p>删除单个脱离的远程分支</p>
<p>git remote prune <name><br>复制代码</p>
<p>取消一次合并（merge）</p>
<p>git merge –abort</p>
<p>回退一次commit</p>
<p>git revert Head/[commit hash]<br>优雅使用Git的一些实践</p>
<p>windows下gitbash支持中文输入：</p>
<p>1）鼠标左键点击左上角git的logo<br>2）找到options并且切换到text目录，将Character set设置为UTF-8<br>复制代码</p>
<p>生成ssh-key</p>
<p>ssh-keygen -t rsa -C “<a href="mailto:&#103;&#x61;&#x6f;&#x6b;&#97;&#x69;&#50;&#48;&#49;&#x30;&#48;&#x38;&#48;&#x31;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#103;&#x61;&#x6f;&#x6b;&#97;&#x69;&#50;&#48;&#49;&#x30;&#48;&#x38;&#48;&#x31;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;</a>“</p>
<p>windows查看ssh-key</p>
<p>/c/Users/frank/.ssh/id_rsa.pub</p>
<p>mac/linux查看ssh-key</p>
<p>cd ~/.ssh<br>ls<br>cat id_rsa.pub</p>
<p>git flow</p>
<p>danielkummer.github.io/git-flow-ch…</p>
<p>误删除stash，该怎么办？</p>
<p>git fsck –unreachable |<br>grep commit | cut -d\  -f3 |<br>xargs git log –merges –no-walk –grep=WIP<br>复制代码<br>找到对应的commit hash值<br>git stash apply 1f55da93d26cd51f15f9e93351dae6b75e25e36f<br>复制代码</p>
<p>.idea修改总是会提醒，.gitignore不生效</p>
<p>.idea/<br>git rm -r –cached .idea<br>复制代码</p>
<p>Git中的origin是什么？</p>
<p>origin是一个变量，代表着一个git仓库地址。可以使用git remote -v查看origin代表的地址。</p>
<p>Git的system，global和local参数分别代表什么？</p>
<p>–system可以输出很多git的系统设置，其中最有用的是alias，例如git s代表了git status，系统所有登录用户有用。<br>–global输出了git的全局设置，主要包括全局的user.name和user.email，优先级低于单个仓库中设置的user.name和user.email，当前用户所有仓库有用。<br>–local输出了git的项目设置，主要包括remote.origin.url以及gitflow的很多配置，只对某个仓库有用。<br>复制代码</p>
<p>Git工作区和暂存区的区别？</p>
<pre><code>   add           commit
</code></pre>
<p>工作目录—-&gt;暂存区—-&gt;版本历史<br>复制代码<br>暂存区：git已经获得了对文件的管理权限，暂存区文件有状态：new file，deleted，modified等等。<br>版本历史：git log查看每一次commit记录。<br>意外收获：<br>若是想非常细粒度的控制commit记录，可以使用git add 指定文件，分开多次commit，每一次commit提交一个细粒度功能的变更文件集合，多次走文件目录 暂存区 版本历史这个流程。<br>复制代码</p>
<p>Git如何重命名文件？</p>
<p>git mv README.md readme.md<br>复制代码</p>
<p>Git的working tree和index是什么意思？</p>
<p>index指的是git索引，可以理解成git有文件的一个复制，仅删除index则仅删除存在于git中的文件。<br>working tree则是指操作系统的工作树，也就是操作系统的磁盘上存储的文件。<br>举两个常用的例子：</p>
<ol>
<li>仅删除git index中的文件，.idea等IDE隐藏的工作树文件是不能删除的：**–cached**<br>git rm –cached -r .idea // <strong>–cached仅仅删除index</strong>，-r（recursive）递归删除.idea目录下的所有文件</li>
<li>删除index和working tree上的文件，恩断义绝</li>
</ol>
<p>git rm 删除index上和working tree上的文件，<br>仅仅删除working tree不删除index的情况，不存在。<br>复制代码</p>
<p>nothing to commit 和 working tree clean?</p>
<p>暂存区没有可以提交到版本历史的内容。<br>工作区也是干净的。<br>复制代码</p>
<p>如何一目了然地区分出工作区和暂存区？</p>
<p>Your branch is ahead of ‘origin/master’ by 1 commit 版本历史<br>Changes to be committed 暂存区<br>Untracked files 工作区</p>
<p>// 版本历史<br>Your branch is ahead of ‘origin/master’ by 1 commit.<br>  (use “git push” to publish your local commits)<br>// 暂存区<br>Changes to be committed:<br>  (use “git reset HEAD <file>…” to unstage)</p>
<pre><code>    renamed:    readme.md -&gt; README.md
    new file:   helloman
</code></pre>
<p>// 工作区<br>Untracked files:<br>  (use “git add <file>…” to include in what will be committed)</p>
<pre><code>    hi
</code></pre>
<p>复制代码</p>
<p>如何更加优雅地查看日志？</p>
<p>git log –oneline 简洁的commit记录<br>git log -n2 –oneline 最近的2次简洁的commit记录<br>git log –all 所有分支的历史版本信息<br>git log –graph 图形化查看版本演进历史<br>git log –oneline –all -n4 –graph 组合查看日志<br>复制代码</p>
<p>如何快速定位到git的命令文档？</p>
<p>git help –web log 浏览器查看git log的用法</p>
<p>git自带的图形化界面怎么看？</p>
<p>gitk 无需安装第三方插件，在纯命令行下，无第三方软件情况下可用。</p>
<p>git 里的作者和提交人不一样吗？</p>
<p>作者是代码的生成者，是为了版权保护。</p>
<p>神秘的.git目录</p>
<p>HEAD 工作分支refs/heads/foo<br>config repo的配置信息<br>refs heads，分支；tags，标签或者里程碑<br>refs/heads/master 存放了什么，最新的一个commit<br>refs/tags/js01 存放了什么，最新的一个tag，包含一个object<br>objects 文件夹，2个字符的和松散的pack文件夹，存放的是tree，tree下有blob文件<br>复制代码<br>可以直接通过vim修改HEAD，config等信息，和命令的作用是相同的。</p>
<p>如何判断git文件的类型？</p>
<p>git cat-file -t/-p [hash fragment] // -t 类型，-p 内容<br>只要任何文件的文件内容相同，在git眼里，它就是唯一的一个blob。<br>commit<br>tree // 位于objects目录下<br>blob // 位于objects目录的二级目录下，具体的文件<br>复制代码</p>
<p>tree, commit, blob的区别？</p>
<p>commit：一个commit肯定会对应一棵树，包含了根tree，author，committer，parent等等一个commit对象的信息。<br>tree：取出一个commit，存放了一个快照，这个快照，对应了当前项目的所有的文件夹及其文件的快照，是特定时间的整个仓库的一个状态；树里可以有blob，也可以有树，因为树是文件夹；根树是最大的树。<br>blob:  与文件名是否相同无关，只要内容相同，就是唯一的blob。<br>复制代码</p>
<p>一个commit包含了哪些？</p>
<p>git cat-file -p [commit hash fragment]<br>复制代码<br>包含tree，parent，author和commiter。<br>tree f06f7f36af17cb9098031c66d22a7910c0fa1bac<br>parent 92a55c8a5b1d38d224232ad84b9b728ae77189cb<br>parent eda632a1f2a3ea049c5f5268f6b2f064b71898ce<br>author FrankKai <a href="mailto:&#x67;&#97;&#x6f;&#x6b;&#97;&#x69;&#x32;&#x30;&#x31;&#48;&#x30;&#56;&#x30;&#49;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;">&#x67;&#97;&#x6f;&#x6b;&#97;&#x69;&#x32;&#x30;&#x31;&#48;&#x30;&#56;&#x30;&#49;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;</a> 1548139120 +0800<br>committer FrankKai <a href="mailto:&#103;&#97;&#111;&#107;&#97;&#x69;&#50;&#x30;&#x31;&#48;&#x30;&#56;&#48;&#x31;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;">&#103;&#97;&#111;&#107;&#97;&#x69;&#50;&#x30;&#x31;&#48;&#x30;&#56;&#48;&#x31;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;</a> 1548139120 +0800</p>
<p>Merge branch ‘feature/chatBreakChange’ into prerelease</p>
<h1 id="Conflicts"><a href="#Conflicts" class="headerlink" title="Conflicts:"></a>Conflicts:</h1><h1 id="src-api-chat-js"><a href="#src-api-chat-js" class="headerlink" title="src/api/chat.js"></a>src/api/chat.js</h1><p>复制代码</p>
<p>一个tree包含了哪些？</p>
<p>git cat-file -p [tree hash fragment]<br>复制代码<br>包含tree，blob。<br>100644 blob 015aaf344153ed7822069b2a98898b7d7a215b0d    .babelrc<br>100644 blob 9d08a1a828a3bd2d60de3952744df29f9add27fa    .editorconfig<br>100644 blob 080140b833db5b758b1eb869a269f4bbb068a19e    .eslintignore<br>100644 blob 8f777c376c0314e480f9bbba273d4902810bcb11    .eslintrc.js<br>100644 blob 895e844218637929546ed2295ae90f991ceb5d38    .gitignore<br>100644 blob db7b635d23657349dbe4c33cc353ef4efd8ca960    .npmrc<br>100644 blob 797e871f4b8c0a3071e8b6ab2cc40b804cd2971c    .postcssrc.js<br>100644 blob d3983c1d6a5525aae58b823448723434ca83ceed    .prettierrc<br>100644 blob 93cc7473ab066204f3329221111a945e2dc83576    BUS.md<br>100644 blob defc3d9914d1af08e6670b96995261bfe1fb61a6    CHANGELOG.md<br>100644 blob bfd46fd4008cbe7103181fc5cd64392a74426e96    MQTT.md<br>100644 blob abdb55935d833dd4f4b79475aa7d63ffcb0cc9cd    README.md<br>040000 tree f1f80f844bb80389826198a15ec0f224a53525f8    build<br>100644 blob 2aefa3130f4ff753b5c3e538db53b9b186f12540    index.html<br>100644 blob 967b8f243420a9a8a07b8f429f0a7ba874a834ad    package-lock.json<br>100644 blob 35d9fa46f569395b25a87daef4820de42d071831    package.json<br>040000 tree f6bdc675a8f9af805867b5a19c263e5bbfe4c26c    src<br>040000 tree 09e231414b91779326447a0c8d5b3421aa2308c2    static<br>040000 tree ad94369cfdd2038a552e44fc0abbd1738113b5e6    test<br>100644 blob 0b96f21c27a3759cecde02fba1e050d86a8e9a54    yarn.lock<br>复制代码</p>
<p>一个blob包含了哪些？</p>
<p>git cat-file -p [tree hash fragment]<br>就是一个具体的文件。<br>复制代码</p>
<p>detached HEAD是什么？</p>
<p>分离头指针。<br><code>git checkout [commit hash fragment]</code>，切换到分离头指针状态，不与任何branch或tag关联，git会认为这是不重要的，当成垃圾清理掉。<br>缺点：切换分支后，需要用<code>git branch [branch name] [commit hash fragment]</code>新建一个分支，否则会丢失原消息。<br>优点：可以基于某一次commit切出分支，然后新建一个commit，快速会退到想要的版本。<br>复制代码</p>
<p>HEAD可以指向什么？</p>
<p>它位于.git/HEAD。<br>可以指向分支或者commit，<strong>但其实分支归根结底还是指向了commit</strong>。<br>git log 查看HEAD指针指向的分支名：<code>(HEAD-&gt;foo, bar, master)</code><br>可以快速diff，<code>git diff HEAD [commit hash fragment]</code>。<br>父亲的父亲diff：<code>git diff HEAD HEAD~2</code>，<code>git diff HEAD HEAD^^</code>。<br>复制代码</p>
<p>如何修改最新一次commit的message？</p>
<p>git commit –amend<br>注意：不能在团队的集成分支上，做这样的变更，仅适用于本地。</p>
<p>如何修改老旧commit的message？</p>
<p>git rebase -i [父 commit hash fragment]<br>reward<br>添加修改后的commit message<br>注意：不能在团队的集成分支上，做这样的变更，仅适用于本地。<br>复制代码</p>
<p>git stash pop stash@{n}还能做什么操作？</p>
<p>当前分支的本地代码未提交的情况下，pull了领先的远程分支代码，此时远程代码会覆盖本地代码。<br>git比较聪明，它不会完全将本地的代码扔掉，即使没有人为的生成一次commit记录，也会自动为我们在stash下生成一次记录，以免造成重大的代码丢失。<br>复制代码</p>
<p>gitflow模式下，如何规范版本发布？</p>
<p>版本号升级gitflow对应bug -&gt; patchhotfixfeature-&gt;minorrelease系统重构-&gt;majorrelease<br>但是在scrum的情况下，迭代非常快速，若所有feature都升级minor，会导致minor数字很大，该怎么处理这种情况？<br>只升级minor时，在commit提交信息中，添加以下信息：</p>
<p>类型提交信息bug patch[bug patch]feature patch[feature patch</p>
<p>创建一个新的项目并上传到git</p>
<p>git init<br>git ac<br>git remote add origin remote repository URL<br>复制代码</p>
<p>git参数–decorate是什么？</p>
<p>有short，full，auto，no几种值，–decorate=short<br>打印出commit的ref name。<br>short时，ref name 前缀refs/head,refs/tags/和refs/remotes不会打印<br>full时，完整前缀会被打印<br>auto时，如果输出是一个终端，会按照short的方式打印；非终端会显示全部<br>no时，会隐藏HEAD和tag等等refs信息<br>默认值是short</p>
<p>cherry pick是什么？</p>
<p>如何理解git cherry pick？</p>
<p>清空所有本地git 缓存</p>
<p>git rm -r –cache .<br>复制代码</p>
<p>error Command “husky-run” not found</p>
<p>rm -rf .git/hooks/</p>
<p>一次完整的rebase流程</p>
<ol>
<li>git checkout feature</li>
<li>git rebase master</li>
<li>resolve conflicts</li>
<li>git add .</li>
<li>git rebase –continue<br>复制代码</li>
</ol>
<p>git revert和git reset的区别</p>
<p>git revert 生成一个新的commit的方式回滚到上一个或者指定commit版本的代码，原理是Head继续前进。有存在被回滚掉的commit分支代码合并过来时，代码正常被合并</p>
<p>git reset 删除某个commit之后的代码，原理是Head向后退。有存在被回滚掉的commit分支代码合并过来时，被reset掉的代码仍然会合并上来<br>复制代码<br>oh-my-zsh 常用命令<br>缩写全写对照表</p>
<p>缩写全写gstgit statusgaagit add .gcmsg “”git commit -m “”gpgit pushgloggit log –oneline –decorate –graphglgit pullgfgit fetchgfagit fetch –all –prune<br>使用小技巧</p>
<p>如何修改默认指令的参数，比如，glog的decorate默认是short，我想指定glog的decorate为no，要怎么做？</p>
<p>glog –decorate=no</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/20/vue3%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BdefineProps%E5%92%8CdefineEmits/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尘世幽梦的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/20/vue3%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BdefineProps%E5%92%8CdefineEmits/" class="post-title-link" itemprop="url">vue3新特性之defineProps和defineEmits</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-20 10:34:43" itemprop="dateCreated datePublished" datetime="2021-12-20T10:34:43+08:00">2021-12-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-14 16:07:32" itemprop="dateModified" datetime="2022-02-14T16:07:32+08:00">2022-02-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="defineProps和defineEmits以及defineExpose"><a href="#defineProps和defineEmits以及defineExpose" class="headerlink" title="defineProps和defineEmits以及defineExpose"></a>defineProps和defineEmits以及defineExpose</h1><h2 id="defineProps-在子组件中获取父组件传值-父组件给子组件传的值"><a href="#defineProps-在子组件中获取父组件传值-父组件给子组件传的值" class="headerlink" title="defineProps-在子组件中获取父组件传值-父组件给子组件传的值"></a>defineProps-在子组件中获取父组件传值-父组件给子组件传的值</h2><ul>
<li>相当于vue2组件中的props属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue3中的使用：</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  const props &#x3D; defineProps(&#123;</span><br><span class="line">    msg: String,</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: () &#x3D;&gt; &#123;</span><br><span class="line">        return &#39;默认值&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="defineEmits-用于子组件给父组件事件传递"><a href="#defineEmits-用于子组件给父组件事件传递" class="headerlink" title="defineEmits - 用于子组件给父组件事件传递"></a>defineEmits - 用于子组件给父组件事件传递</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">const emit &#x3D; defineEmits([&#39;changeState&#39;])</span><br><span class="line">const emitChangeState &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  emit(&#39;changeState&#39;, true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;parentCom @changeState&#x3D;&quot;changeState&quot;&gt;&lt;&#x2F;parentCom&gt;</span><br><span class="line">const changeState &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(e); &#x2F;&#x2F; e是子组件传递的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="defineExpose-组件暴露自己的属性"><a href="#defineExpose-组件暴露自己的属性" class="headerlink" title="defineExpose - 组件暴露自己的属性"></a>defineExpose - 组件暴露自己的属性</h2><p>  在vue3.x的setup语法糖中定义的变量默认不会暴露出去，这时使用definExpose({ })来暴露组件内部属性给父组件使用<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">  import &#123; ref &#125; from &#39;vue&#39;</span><br><span class="line">  const count &#x3D; ref(123456)</span><br><span class="line">  defineExpose(&#123;</span><br><span class="line">    count</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">  import &#123; ref &#125; from &#39;vue&#39;</span><br><span class="line">  const child &#x3D; ref(null)</span><br><span class="line">  child.value.count &#x2F;&#x2F; 获取子组件的count  &#x2F;&#x2F; 123456</span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/18/21-11-18-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尘世幽梦的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/18/21-11-18-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">21-11-18-设计模式-单例模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-18 15:55:16 / Modified: 16:46:40" itemprop="dateCreated datePublished" datetime="2021-11-18T15:55:16+08:00">2021-11-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="设计模式-单例模式"><a href="#设计模式-单例模式" class="headerlink" title="设计模式-单例模式"></a>设计模式-单例模式</h1><blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
</blockquote>
<blockquote>
<p>用一个变量来记录当前是否已为该类创建过对象，是则在下次获取该类实例时直接返回之前创建的对象</p>
</blockquote>
<h2 id="透明的单例模式（代理）"><a href="#透明的单例模式（代理）" class="headerlink" title="透明的单例模式（代理）"></a>透明的单例模式（代理）</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var CreateDiv &#x3D; function( html ) &#123;</span><br><span class="line">    this.html &#x3D; html</span><br><span class="line">    this.init()</span><br><span class="line">&#125;</span><br><span class="line">CreateDiv.prototype.init &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 待执行的操作</span><br><span class="line">    var div &#x3D; document.createElement(&#39;div&#39;)</span><br><span class="line">    div.innerHTML &#x3D; this.html</span><br><span class="line">    document.body.appendChild(div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代理类</span><br><span class="line">var ProxySingletonCreateDiv &#x3D; (function() &#123;</span><br><span class="line">    var instance</span><br><span class="line">    return function(html) &#123;</span><br><span class="line">        if(!instance) &#123;</span><br><span class="line">            instance &#x3D; new CreateDiv(html)</span><br><span class="line">        &#125;</span><br><span class="line">        return instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">var a &#x3D; new ProxySingletonCreateDiv(&#39;a&#39;)</span><br><span class="line"></span><br><span class="line">var b &#x3D; new ProxySingletonCreateDiv(&#39;b&#39;) </span><br><span class="line">&#x2F;&#x2F; 由于前面存在了a实例，所以该实例不会去调用new CreateDiv(html)函数了，所以此处返回的还是前面返回的实例，即a实例</span><br><span class="line">console.log(a &#x3D;&#x3D;&#x3D; b) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">作者：moe_</span><br><span class="line">链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7031461636158259214</span><br><span class="line">来源：稀土掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h2><blockquote>
<p>惰性单例只有在需要的时候才创建对象实例。实现思路如最开始，用一个变量来标志是否创建过对象，是则返回创建好的对象。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var getSingle &#x3D; function(fn) &#123;</span><br><span class="line">    var result </span><br><span class="line">    return function() &#123;</span><br><span class="line">        return result || (result &#x3D; fn.apply(this,arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：moe_</span><br><span class="line">链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7031461636158259214</span><br><span class="line">来源：稀土掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/20/vue%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AEpackage-json%E4%B8%AD%E7%9A%84%E6%89%93%E5%8C%85%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尘世幽梦的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/20/vue%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AEpackage-json%E4%B8%AD%E7%9A%84%E6%89%93%E5%8C%85%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">vue手动配置package.json中的打包命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-10-20 16:58:30 / Modified: 17:19:12" itemprop="dateCreated datePublished" datetime="2021-10-20T16:58:30+08:00">2021-10-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vue手动配置package-json中的打包命令"><a href="#vue手动配置package-json中的打包命令" class="headerlink" title="vue手动配置package.json中的打包命令"></a>vue手动配置package.json中的打包命令</h1><p>pacakage.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;, &#x2F;&#x2F; 打包命令-打包整个项目</span><br><span class="line">    &quot;custBuild&quot;: &quot;vue-cli-service build --target lib --name vue-msg-cwj --dest lib src&#x2F;plugins&#x2F;index.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><h3 id="vue-cli-service-serve-启动一个开发服务器"><a href="#vue-cli-service-serve-启动一个开发服务器" class="headerlink" title="vue-cli-service serve  启动一个开发服务器"></a>vue-cli-service serve  启动一个开发服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(基于 webpack-dev-server) 并附带开箱即用的模块热重载 (Hot-Module-Replacement)</span><br><span class="line"></span><br><span class="line">用法：vue-cli-service serve [options] [entry]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  --open    在服务器启动时打开浏览器</span><br><span class="line">  --copy    在服务器启动时将 URL 复制到剪切版</span><br><span class="line">  --mode    指定环境模式 (默认值：development)</span><br><span class="line">  --host    指定 host (默认值：0.0.0.0)</span><br><span class="line">  --port    指定 port (默认值：8080)</span><br><span class="line">  --https   使用 https (默认值：false)</span><br></pre></td></tr></table></figure>
<h3 id="vue-cli-service-build-打包命令"><a href="#vue-cli-service-build-打包命令" class="headerlink" title="vue-cli-service build 打包命令"></a>vue-cli-service build 打包命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">用法：vue-cli-service build [options] [entry|pattern]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  --mode        指定环境模式 (默认值：production)</span><br><span class="line">  --dest        指定输出目录 (默认值：dist)</span><br><span class="line">  --modern      面向现代浏览器带自动回退地构建应用</span><br><span class="line">  --target      app | lib | wc | wc-async (默认值：app)</span><br><span class="line">  --name        库或 Web Components 模式下的名字 (默认值：package.json 中的 &quot;name&quot; 字段或入口文件名)</span><br><span class="line">  --no-clean    在构建项目之前不清除目标目录</span><br><span class="line">  --report      生成 report.html 以帮助分析包内容</span><br><span class="line">  --report-json 生成 report.json 以帮助分析包内容</span><br><span class="line">  --watch       监听文件变化</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/09/axios%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8promise%E6%97%A0%E7%97%9B%E5%88%B7%E6%96%B0token/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尘世幽梦的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/09/axios%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8promise%E6%97%A0%E7%97%9B%E5%88%B7%E6%96%B0token/" class="post-title-link" itemprop="url">axios如何利用promise无痛刷新token</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-09 15:06:25 / Modified: 15:46:46" itemprop="dateCreated datePublished" datetime="2021-07-09T15:06:25+08:00">2021-07-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="axios如何利用promise无痛刷新token"><a href="#axios如何利用promise无痛刷新token" class="headerlink" title="axios如何利用promise无痛刷新token"></a>axios如何利用promise无痛刷新token</h1><h2 id="方法一：-利用axios拦截器在请求之前拦截"><a href="#方法一：-利用axios拦截器在请求之前拦截" class="headerlink" title="方法一： 利用axios拦截器在请求之前拦截"></a>方法一： 利用axios拦截器在请求之前拦截</h2><p>在请求之前拦截的话，则需要让后端在刷新token的接口中返回一个失效时间段，比如一个小时3000秒。（放过刷新token接口以及登录接口）根据当前时间与计算之后的失效时间做比较，如果当前时间大于失效时间，就说明需要调用重新刷新token。为了防止多次个请求进来导致多次刷新token，我们需要设置一个唯一标识来处理。为了处理在token已经过期或者刷新token的时候，还有请求发起，此时需要让后面的请求等一等，等到token刷新接口结束之后再真正发起，此时需要借助promise来实现，因为promise如果不返回的话，状态会一直是pending.</p>
<p>完整代码：在请求之前拦截<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从localStorage中获取token，token存的是object信息，有tokenExpireTime和token两个字段</span><br><span class="line">function getToken () &#123;</span><br><span class="line">  let tokenObj &#x3D; &#123;&#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    tokenObj &#x3D; storage.get(&#39;token&#39;)</span><br><span class="line">    tokenObj &#x3D; tokenObj ? JSON.parse(tokenObj) : &#123;&#125;</span><br><span class="line">  &#125; catch &#123;</span><br><span class="line">    console.error(&#39;get token from localStorage error&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  return tokenObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function refreshToken () &#123;</span><br><span class="line">    &#x2F;&#x2F; instance是当前request.js中已创建的axios实例</span><br><span class="line">    return instance.post(&#39;&#x2F;refreshtoken&#39;).then(res &#x3D;&gt; res.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给实例添加一个setToken方法，用于登录后方便将最新token动态添加到header，同时将token保存在localStorage中</span><br><span class="line">instance.setToken &#x3D; (obj) &#x3D;&gt; &#123;</span><br><span class="line">  instance.defaults.headers[&#39;X-Token&#39;] &#x3D; obj.token</span><br><span class="line">  window.localStorage.setItem(&#39;token&#39;, JSON.stringify(obj)) &#x2F;&#x2F; 注意这里需要变成字符串后才能放到localStorage中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">instance.interceptors.request.use((config) &#x3D;&gt; &#123;</span><br><span class="line">  const tokenObj &#x3D; getToken()</span><br><span class="line">  &#x2F;&#x2F; 添加请求头</span><br><span class="line">  config.headers[&#39;X-Token&#39;] &#x3D; tokenObj.token</span><br><span class="line">  &#x2F;&#x2F; 登录接口和刷新token接口绕过</span><br><span class="line">  if (config.url.indexOf(&#39;&#x2F;rereshToken&#39;) &gt;&#x3D; 0 || config.url.indexOf(&#39;&#x2F;login&#39;) &gt;&#x3D; 0) &#123;</span><br><span class="line">    return config</span><br><span class="line">  &#125;</span><br><span class="line">  if (tokenObj.token &amp;&amp; tokenObj.tokenExpireTime) &#123;</span><br><span class="line">    const now &#x3D; Date.now()</span><br><span class="line">    if (now &gt;&#x3D; tokenObj.tokenExpireTime) &#123;</span><br><span class="line">      &#x2F;&#x2F; 立即刷新token</span><br><span class="line">      if (!isRefreshing) &#123;</span><br><span class="line">        console.log(&#39;刷新token ing&#39;)</span><br><span class="line">        isRefreshing &#x3D; true</span><br><span class="line">        refreshToken().then(res &#x3D;&gt; &#123;</span><br><span class="line">          const &#123; token, tokenExprieIn &#125; &#x3D; res.data</span><br><span class="line">          const tokenExpireTime &#x3D; now + tokenExprieIn * 1000</span><br><span class="line">          instance.setToken(&#123; token, tokenExpireTime &#125;)</span><br><span class="line">          isRefreshing &#x3D; false</span><br><span class="line">          return token</span><br><span class="line">        &#125;).then((token) &#x3D;&gt; &#123;</span><br><span class="line">          console.log(&#39;刷新token成功，执行队列&#39;)</span><br><span class="line">          requests.forEach(cb &#x3D;&gt; cb(token))</span><br><span class="line">          &#x2F;&#x2F; 执行完成后，清空队列</span><br><span class="line">          requests &#x3D; []</span><br><span class="line">        &#125;).catch(res &#x3D;&gt; &#123;</span><br><span class="line">          console.error(&#39;refresh token error: &#39;, res)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      const retryOriginalRequest &#x3D; new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">        requests.push((token) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 因为config中的token是旧的，所以刷新token后要将新token传进来</span><br><span class="line">          config.headers[&#39;X-Token&#39;] &#x3D; token</span><br><span class="line">          resolve(config)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      return retryOriginalRequest</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return config</span><br><span class="line">&#125;, (error) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Do something with request error</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请求返回后拦截</span><br><span class="line">instance.interceptors.response.use(response &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; code &#125; &#x3D; response.data</span><br><span class="line">  if (code &#x3D;&#x3D;&#x3D; 1234) &#123;</span><br><span class="line">    &#x2F;&#x2F; token过期了，直接跳转到登录页 </span><br><span class="line">    window.location.href &#x3D; &#39;&#x2F;&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  return response</span><br><span class="line">&#125;, error &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;catch&#39;, error)</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default instance</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;作者：fengxianqi</span><br><span class="line">&#x2F;&#x2F;链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844903993274007565</span><br><span class="line">&#x2F;&#x2F;来源：掘金</span><br><span class="line">&#x2F;&#x2F;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
<h2 id="方法二：利用axios拦截器在请求之后拦截"><a href="#方法二：利用axios拦截器在请求之后拦截" class="headerlink" title="方法二：利用axios拦截器在请求之后拦截"></a>方法二：利用axios拦截器在请求之后拦截</h2><p>与后端约定token过期会返回的数据结构，根据数据结构判断是否token过期，过期则刷新token。<br>为了防止多次刷新token，需要使用一个唯一标识来标记当前是否在刷新token的状态。如果正在刷新则不再调用刷新token的接口。同时发起两个或以上的请求时，其他接口如何重试？先将这个请求存到一个数组队列中，想办法让这个请求处于等待中，一直等到刷新token后再逐个重试清空请求队列。<br>那么如何做到让这个请求处于等待中呢？为了解决这个问题，我们得借助Promise。将请求存进队列中后，同时返回一个Promise，让这个Promise一直处于Pending状态（即不调用resolve），此时这个请求就会一直等啊等，只要我们不执行resolve，这个请求就会一直在等待。当刷新请求的接口返回来后，我们再调用resolve</p>
<p>完整代码：在请求之后拦截<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从localStorage中获取token</span><br><span class="line">function getLocalToken () &#123;</span><br><span class="line">    const token &#x3D; window.localStorage.getItem(&#39;token&#39;)</span><br><span class="line">    return token</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</span><br><span class="line">instance.setToken &#x3D; (token) &#x3D;&gt; &#123;</span><br><span class="line">  instance.defaults.headers[&#39;X-Token&#39;] &#x3D; token</span><br><span class="line">  window.localStorage.setItem(&#39;token&#39;, token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function refreshToken () &#123;</span><br><span class="line">    &#x2F;&#x2F; instance是当前request.js中已创建的axios实例</span><br><span class="line">    return instance.post(&#39;&#x2F;refreshtoken&#39;).then(res &#x3D;&gt; res.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个axios实例</span><br><span class="line">const instance &#x3D; axios.create(&#123;</span><br><span class="line">  baseURL: &#39;&#x2F;api&#39;,</span><br><span class="line">  timeout: 300000,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">    &#39;X-Token&#39;: getLocalToken() &#x2F;&#x2F; headers塞token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 是否正在刷新的标记</span><br><span class="line">let isRefreshing &#x3D; false</span><br><span class="line">&#x2F;&#x2F; 重试队列，每一项将是一个待执行的函数形式</span><br><span class="line">let requests &#x3D; []</span><br><span class="line"></span><br><span class="line">instance.interceptors.response.use(response &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; code &#125; &#x3D; response.data</span><br><span class="line">  if (code &#x3D;&#x3D;&#x3D; 1234) &#123;</span><br><span class="line">    const config &#x3D; response.config</span><br><span class="line">    if (!isRefreshing) &#123;</span><br><span class="line">      isRefreshing &#x3D; true</span><br><span class="line">      return refreshToken().then(res &#x3D;&gt; &#123;</span><br><span class="line">        const &#123; token &#125; &#x3D; res.data</span><br><span class="line">        instance.setToken(token)</span><br><span class="line">        config.headers[&#39;X-Token&#39;] &#x3D; token</span><br><span class="line">        config.baseURL &#x3D; &#39;&#39;</span><br><span class="line">        &#x2F;&#x2F; 已经刷新了token，将所有队列中的请求进行重试</span><br><span class="line">        requests.forEach(cb &#x3D;&gt; cb(token))</span><br><span class="line">        requests &#x3D; []</span><br><span class="line">        return instance(config)</span><br><span class="line">      &#125;).catch(res &#x3D;&gt; &#123;</span><br><span class="line">        console.error(&#39;refreshtoken error &#x3D;&gt;&#39;, res)</span><br><span class="line">        window.location.href &#x3D; &#39;&#x2F;&#39;</span><br><span class="line">      &#125;).finally(() &#x3D;&gt; &#123;</span><br><span class="line">        isRefreshing &#x3D; false</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 正在刷新token，将返回一个未执行resolve的promise</span><br><span class="line">      return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span><br><span class="line">        requests.push((token) &#x3D;&gt; &#123;</span><br><span class="line">          config.baseURL &#x3D; &#39;&#39;</span><br><span class="line">          config.headers[&#39;X-Token&#39;] &#x3D; token</span><br><span class="line">          resolve(instance(config))</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return response</span><br><span class="line">&#125;, error &#x3D;&gt; &#123;</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default instance</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/08/html%E3%80%81css%E3%80%81js%E4%B8%89%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尘世幽梦的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/08/html%E3%80%81css%E3%80%81js%E4%B8%89%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">html、css、js三大基础知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-08 14:25:39 / Modified: 15:23:16" itemprop="dateCreated datePublished" datetime="2021-07-08T14:25:39+08:00">2021-07-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="html，css，js三者的加载顺序问题"><a href="#html，css，js三者的加载顺序问题" class="headerlink" title="html，css，js三者的加载顺序问题"></a>html，css，js三者的加载顺序问题</h2><p>  DOM文档的加载顺序是由上而下的顺序加载</p>
<ol>
<li><span style="color: red;">DOM加载到link标签</span><ul>
<li>css文件的加载是与DOM的加载并行的。也就是说css加载时，DOM还在继续构建。在DOM构建的过程中，遇到css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中相对的位置中。</li>
</ul>
</li>
<li><span style="color: red;">DOM加载到script标签</span><ul>
<li><span style="color: yellow;">js文件不会和DOM并行加载的。需要等待整个js加载完成之后才能继续加载DOM</span>，如果js脚本过大的话，可能会导致浏览器页面显示滞后，出现假死状态，这种效应称之为阻塞效应。</li>
<li>js文件中一般都是调用ready函数或者onload函数，让DOM文档加载完成之后再执行js代码，这样才不会存在找不到Dom节点的情况。</li>
<li>js阻塞其他资源的加载的原因是：浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现</li>
</ul>
</li>
<li>解决方案<ul>
<li>script标签中添加 defer=“ture”，则会让js与DOM并行加载，待页面加载完成后再执行js文件，这样则不存在阻塞</li>
<li>scirpt标签中添加 async=“ture”，这个属性告诉浏览器该js文件是异步加载执行的。无法保证js文件的加载顺序，但是同样有与DOM并行加载的效果</li>
<li>同时使用defer和async属性时，defer属性会失效</li>
<li>将scirpt标签放在body标签之后，这样就不会出现加载的冲突了</li>
</ul>
</li>
</ol>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>  css加载时和Dom并行加载的，但是css会阻塞DOM的渲染，DOM的渲染之后等css加载完成之后才能执行。这涉及到浏览器的渲染机制。</p>
<h4 id="浏览器的渲染机制："><a href="#浏览器的渲染机制：" class="headerlink" title="浏览器的渲染机制："></a>浏览器的渲染机制：</h4><ul>
<li>解析html文件，生成DOM树</li>
<li>解析css文件，生成css规则树</li>
<li>待DOM树与css规则树生成之后，DOM树与css规则树结合生成render规则树</li>
<li>根据render树中的节点信息去在浏览器中渲染绘制</li>
</ul>
<h4 id="组织语言："><a href="#组织语言：" class="headerlink" title="组织语言："></a>组织语言：</h4><p>  关于DOM文档的加载顺序，DOM文档的加载顺序是<span style="color: yellow;">由上而下的顺序加载</span>，在DOM加载到link标签时，由于<span style="color: yellow;">css文件的加载时与DOM加载并行的</span>，所以<span style="color: yellow;">css的不会阻止DOM的解析，但是可能会阻塞DOM的渲染</span>，因为不确定css文件是否会在DOM加载完成之后解析完成。然后在DOM执行到script标签的时候，由于<span style="color: yellow;">js文件和DOM不是并行加载的</span>，<span style="color: yellow;">DOM加载需要等待js文件加载完成之后才能继续加载DOM</span>。所以可能会存在阻塞，所以我们一般会<span style="color: yellow;">把script标签放到body标签之后.然后就是如果我们不是把script放在body后面的话，那么我们也可以通过defer和async属性来达到效果</span>。如果是只设置了defer的，会让js文件和DOM并行加载的，等到DOM加载完成之后才会去执行js文件。如果设置async的话，能够实现js文件和DOM的并行加载，但是无法保证js文件的加载顺序。同时使用defer和async属性时，defer属性会失效</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/07/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尘世幽梦的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/07/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">自适应布局与响应式布局</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-07 17:22:06 / Modified: 17:33:18" itemprop="dateCreated datePublished" datetime="2021-07-07T17:22:06+08:00">2021-07-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h2><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p>  <span style="font-size: 20px;color: #ffffff;font-weight: bold;">postcss-px-to-viewport 插件</span>  </p>
<h4 id="方案选择："><a href="#方案选择：" class="headerlink" title="方案选择："></a>方案选择：</h4><ul>
<li>只做移动端<ul>
<li>postcss-px-to-viewport – vw方法 （一把梭，什么都不用考虑。且是最真实的按照屏幕大小的比例来放大缩小。）</li>
</ul>
</li>
<li>小屏设计图向上兼容自适应大屏幕/大屏设计图向下兼容自适应小屏幕<ul>
<li>postcss-px-to-viewport – rem（当需要从移动端设计图适配到平板、PC屏幕）最方便</li>
</ul>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li>我们先把它安装到项目的开发环境中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i postcss-px-to-viewport -D</span><br></pre></td></tr></table></figure></li>
<li>在项目根目录下添加.postcssrc.js文件</li>
<li>添加如下配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;&#125;, &#x2F;&#x2F; 用来给不同的浏览器自动添加相应前缀，如-webkit-，-moz-等等</span><br><span class="line">    &quot;postcss-px-to-viewport&quot;: &#123;</span><br><span class="line">      unitToConvert: &quot;px&quot;, &#x2F;&#x2F; 要转化的单位</span><br><span class="line">      viewportWidth: 750, &#x2F;&#x2F; UI设计稿的宽度</span><br><span class="line">      unitPrecision: 6, &#x2F;&#x2F; 转换后的精度，即小数点位数</span><br><span class="line">      propList: [&quot;*&quot;], &#x2F;&#x2F; 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span><br><span class="line">      viewportUnit: &quot;vw&quot;, &#x2F;&#x2F; 指定需要转换成的视窗单位，默认vw</span><br><span class="line">      fontViewportUnit: &quot;vw&quot;, &#x2F;&#x2F; 指定字体需要转换成的视窗单位，默认vw</span><br><span class="line">      selectorBlackList: [&quot;wrap&quot;], &#x2F;&#x2F; 指定不转换为视窗单位的类名，</span><br><span class="line">      minPixelValue: 1, &#x2F;&#x2F; 默认值1，小于或等于1px则不进行转换</span><br><span class="line">      mediaQuery: true, &#x2F;&#x2F; 是否在媒体查询的css代码中也进行转换，默认false</span><br><span class="line">      replace: true, &#x2F;&#x2F; 是否转换后直接更换属性值</span><br><span class="line">      exclude: [&#x2F;node_modules&#x2F;], &#x2F;&#x2F; 设置忽略文件，用正则做目录名匹配</span><br><span class="line">      landscape: false &#x2F;&#x2F; 是否处理横屏情况</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>重新运行项目，使配置文件生效<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;test-viewport&quot;&gt;测试转换&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">.test-viewport &#123;</span><br><span class="line">  width: 750px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  font-size: 40px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 100px;</span><br><span class="line">  background: #13b5b1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/07/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尘世幽梦的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/07/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">项目中遇到的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-07 10:48:07 / Modified: 10:53:06" itemprop="dateCreated datePublished" datetime="2021-07-07T10:48:07+08:00">2021-07-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-使用动态添加路由addRoutes-会遇到的问题"><a href="#1-使用动态添加路由addRoutes-会遇到的问题" class="headerlink" title="1.使用动态添加路由addRoutes()会遇到的问题"></a>1.使用动态添加路由addRoutes()会遇到的问题</h3><p>  在addRoutes()之后<span style="color: #c7254e;">第一次访问被添加的路由</span>会白屏，这是因为刚刚addRoutes()就立刻访问被添加的路由，然而此时addRoutes()没有执行结束，因而找不到刚刚被添加的路由导致白屏。因此需要从新访问一次路由才行</p>
<p>  解决方案：使用next({ …to, replace: true })来确保addRoutes()时动态添加的路由已经被完全加载上去；next({ …to, replace: true })中的replace: true只是一个设置信息，告诉VUE本次操作后，不能通过浏览器后退按钮，返回前一个路由</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/02/this%E7%9A%84%E6%8C%87%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尘世幽梦的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/02/this%E7%9A%84%E6%8C%87%E5%90%91/" class="post-title-link" itemprop="url">this的指向</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-02 10:13:24" itemprop="dateCreated datePublished" datetime="2021-07-02T10:13:24+08:00">2021-07-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-12-27 15:47:53" itemprop="dateModified" datetime="2021-12-27T15:47:53+08:00">2021-12-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7042888736077512735">掘金文章</a></p>
<h2 id="this的指向-1"><a href="#this的指向-1" class="headerlink" title="this的指向"></a>this的指向</h2><p>this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁（this永远指向的是最后调用它的对象）</p>
<ul>
<li>1.全局作用域下，this执行window</li>
<li>2.函数作用域下，在非严格模式下，this指向window</li>
<li>3.函数作用域下，在严格模式下，this执行undefined</li>
<li>4.在对象里面，this指向的是当前对象</li>
<li>5.箭头函数的this指向在创建时就已确定（箭头函数不能作为构造函数）(指向的是最外层的作用域，所以如果箭头函数没有被其他的函数包裹，那么this指向的是window对象，反之指向调用其外层函数的对象)</li>
<li>6.new 关键字调用函数，指向是创建的新对象(返回的对象)</li>
<li>7.在定时器函数中，this指向window</li>
<li>8.通过call、apply、bind修改this指向，指向绑定的对象</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
